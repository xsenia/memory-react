создаешь движок
его инициализация в App происходит примерно следущим образом:
this.engine = new Engine(var1, var2, var3);
this.engine это пустая переменная внутри App, инициализируешь движок в неё внутри конструктора

сам движок выглядит примерно так:
class Engine {
  // приходящие из new Engine(...) аргументы принимает конструктор
  // чтобы ими пользоватся внутри класса, нужно положить их в
  // заранее созданные переменные
  constructor(arg1, arg2, arg3){
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.arg3 = arg3;
  }
  
  arg1;
  arg2;
  arg3;

  // методы внутри App будут дергаться легко и просто
  // engine.method_1()
  method_1(){
    ...
    return 123
  }
  
  method_2(){
    ...
    return 123
  }
}

организовываешь код внутри движка таким образом, чтобы часть методов была внешняя, часть для внутреннего пользования
в TS есть public и private и из вне ты реально хрен достучишься до private методов, а точнее получишь ошибку

в js это одна херня, нет пабликов и приватов, поэтому чисто для визуального восприятия кода можешь приватные методы называть с префиксом _
и компановать код так, чтобы сначала шли все публичные, затем все приватные, или наоборот

в публичных методах всё просто, это по сути способы обращения к движку с целью что-то от него получить, либо (реже) что-то в него засетить без получения

типа updateScore() - через этот метод можно сказать "эй, товарищ движок, очередные две карты угаданы, ну ка обнови общее количество очков"
и в return этого метода можно получить getScore(), которая вернет текущее количество очков
либо getScore можно запросить сразу после updateScore (если у нас тут не асинхронщина, но у нас не асинхронщина, гы)

getScore() вообще наитупейший метод, сводящийся к одной строчке:
return this.score

соответственно в score у Engine хранится текущее количество очков



—---------
когда описала движок и инициализировала его в App, можешь отдавать его Кардконтролу - <CardControl engine={this.engine} />

теперь и CardControl может дергать getScore, updateScore и прочие методы для взаимодействия с движком
но главный по-прежнему App, он определяет движок и он его передает кардконтролу, тот просто работает с тем, что ему дали, и не заморачивается


—---------
еще одна важная хреновина - таймер, его можно (и очень желательно) также вынести отдельным классом
в КардКонтроле его также инициализируем - new Timer()
у меня такой вот таймер занял 30 строк кода и имеет он два публичных метода, а еще два приходящих в него при инициализации параметра, один обязательный, второй нет


—---------
таким образом получилось нормальное разделение зон ответственности, которые при этом не пересекаются:
- App - инициализирует приложение (сам себя типа ага), инициализирует движок, знает про текущее состояние игры, рисует нужный экран, при этом рисует довольно примитивно, не вникая в детали - тупо три дитёнка, каждый из которых соответствует одному из трех экранов

- Движок - получает настройки или берет дефолтные, получает и хранит в себе очки, следит за тем, когда игра закончится

- КардКонтрол - рисует карты, ловит и обрабатывает клики по ним, общается с движком для обновления количества очков

- Таймер - избавились от жутких сеттаймаутов (в моем случае сетинтервалов) в КардКонтроле, отдали это дело скажем так на аутсорс))


В итоге раздельная логика, каждый занимается своим делом, задачи компонентов не пересекаются.
Апп не рисует всё подряд и не имеет в себе гору всякой логики;
КардКонтрол не заморачивается за подсчет очков, не следит за тем, когда игра закончится, не вникает в настройки (а лишь забирает их у движка);
Движок - маленькая компактная хрень, изолированная и понятная, она ничо не рисует, а хранит настройки, считает очки и следит когда игра закончится;
Таймер - просто избавление от кода в ненужных местах