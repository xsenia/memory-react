создаешь движок
его инициализация в App происходит примерно следущим образом:
this.engine = new Engine(var1, var2, var3);
this.engine это пустая переменная внутри App, инициализируешь движок в неё внутри конструктора

сам движок выглядит примерно так:
class Engine {
  // приходящие из new Engine(...) аргументы принимает конструктор
  // чтобы ими пользоватся внутри класса, нужно положить их в
  // заранее созданные переменные
  constructor(arg1, arg2, arg3){
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.arg3 = arg3;
  }
  
  arg1;
  arg2;
  arg3;

  // методы внутри App будут дергаться легко и просто
  // engine.method_1()
  method_1(){
    ...
    return 123
  }
  
  method_2(){
    ...
    return 123
  }
}

организовываешь код внутри движка таким образом, чтобы часть методов была внешняя, часть для внутреннего пользования
в TS есть public и private и из вне ты реально хрен достучишься до private методов, а точнее получишь ошибку

в js это одна херня, нет пабликов и приватов, поэтому чисто для визуального восприятия кода можешь приватные методы называть с префиксом _
и компановать код так, чтобы сначала шли все публичные, затем все приватные, или наоборот

в публичных методах всё просто, это по сути способы обращения к движку с целью что-то от него получить, либо (реже) что-то в него засетить без получения

типа updateScore() - через этот метод можно сказать "эй, товарищ движок, очередные две карты угаданы, ну ка обнови общее количество очков"
и в return этого метода можно получить getScore(), которая вернет текущее количество очков
либо getScore можно запросить сразу после updateScore (если у нас тут не асинхронщина, но у нас не асинхронщина, гы)

getScore() вообще наитупейший метод, сводящийся к одной строчке:
return this.score

соответственно в score у Engine хранится текущее количество очков



—---------
когда описала движок и инициализировала его в App, можешь отдавать его Кардконтролу - <CardControl engine={this.engine} />

теперь и CardControl может дергать getScore, updateScore и прочие методы для взаимодействия с движком
но главный по-прежнему App, он определяет движок и он его передает кардконтролу, тот просто работает с тем, что ему дали, и не заморачивается


—---------
еще одна важная хреновина - таймер, его можно (и очень желательно) также вынести отдельным классом
в КардКонтроле его также инициализируем - new Timer()
у меня такой вот таймер занял 30 строк кода и имеет он два публичных метода, а еще два приходящих в него при инициализации параметра, один обязательный, второй нет

class Timer {
  constructor(finishCallback, timeout){
    this.finishCallback = finishCallback;
    this.timeout = timeout || 5;
  }
  
  finishCallback;
  timeout;
  
  start(){
    ...
  }
  
  clear(){
    ...
  }
}

—---------
таким образом получилось нормальное разделение зон ответственности, которые при этом не пересекаются:
- App - инициализирует приложение (сам себя типа ага), инициализирует движок, знает про текущее состояние игры, рисует нужный экран, при этом рисует довольно примитивно, не вникая в детали - тупо три дитёнка, каждый из которых соответствует одному из трех экранов

- Движок - получает настройки или берет дефолтные, получает и хранит в себе очки, следит за тем, когда игра закончится

- КардКонтрол - рисует карты, ловит и обрабатывает клики по ним, общается с движком для обновления количества очков

- Таймер - избавились от жутких сеттаймаутов (в моем случае сетинтервалов) в КардКонтроле, отдали это дело скажем так на аутсорс))


В итоге раздельная логика, каждый занимается своим делом, задачи компонентов не пересекаются.
Апп не рисует всё подряд и не имеет в себе гору всякой логики;
КардКонтрол не заморачивается за подсчет очков, не следит за тем, когда игра закончится, не вникает в настройки (а лишь забирает их у движка);
Движок - маленькая компактная хрень, изолированная и понятная, она ничо не рисует, а хранит настройки, считает очки и следит когда игра закончится;
Таймер - просто избавление от кода в ненужных местах


всё ниже написанное сидит у меня в голове, и конечная реализация может отличаться от этого, потому что я мог что-то забыть / не учесть
расценивай это не как руководство к действию, а как примерный план, по которому надо собрать такую вот хуёвину, которая умеет то-то и то-то



----------------------


GameEngine это классик, который является типа движком игры
он должен уметь:
1) хранить в себе состояние игры - в процессе (началась), закончена
фактически "игра началась" для движка это момент его вызова в Application (смотри ниже)
2) управлять очками - складывать-вычитать
3) опционално может иметь в себе в как минимум две игровых настройки - количество играющих карт (не обязательно жеж 18 разыгрывать) и время показа карты (больше-меньше 5 секунд)

нах он нужен - разгрузить CardControl, разделить логику отрисовки (CardControl рисует массив карт, ну и фактически сами карты с помощью Card, перерисовывает их, следит за переворотами) и логику управления игрой (подсчет очков, текущее состояние игры)

в итоге в Application делаем нечто такое:
const settings = {amount: 20, timeOut: 6};
const gameFinished = this.setState({gameState: 'finished'}); — об этом ниже
const gameEngine = new GameEngine(gameFinished, settings);
settings - опции игры - 1 аргумент количество карт, второй - количество секунд
если ничо не передали, или какой-то из параметров отсутствует, то внутри GameEngine значения выставляются по дефолту - 18 карт и 5 секунд

потом прокидываем движок внутр CardControl:
<CardControl engine={gameEngine} /> - т.е. через пропсы

—---
у GameEngine есть методы:
1) updatePoints - обновляет количество очков, нуждается фактически всего в одном параметре - "отгадано" (булевый)
если "отдадано" = тру, то очки прибавляются, иначе убавляются
соответственно функция обновляет внутри GameEngine значение в перменной, которая хранит количество отгаданных карт
еще там должно быть условие - если количество отгаданных карт === количеству карт всего, то игра заканчивается, значит пора вызвать gameFinished (которая в GameEngine приходит первым аргументом)
если количество отгаданных меньше количества играющих - просто возвращаем в CardControl количество очков (return getPoints) - она описана ниже

фактически мы явно не меняем внутри GameEngine состояние игры на "закончено", мы просто говорим наверх о том, что она таки закончилась

2) getPoints - тупо возвращает количество очков на данный момент

3) getSettings - возвращаем настройки (либо которые пришли при инициализации из Application, либо дефолтные)


с помощью этих методов CardControl общается в движком:
- вначале получает настройки игры, исходя из количества создает массив карт;
- исходя из времени выставляет таймаут (таки сетИнтервал);
- в turnCard дергает updatePoints, отправляя туда тру/фолс на основании результата сравнения уже открытой карты и второй открытой;
- там же получает в ответ из updatePoints текущее количество очков, куда-нибудь их там сетит в стейт опять, рисует их количество в рендере;



по поводу gameFinished в Application - таким образом мы прокидываем внутрь движка функцию, которую движок должен вызвать, когда игра, по его мнению, закончится
функиця эта - "сделать параметр Стейта Application тру, когда игра закончится"
ну и в рендере Application если этот параметр тру, то мы уже не рисуем CardControl, мы рисуем финишный экран
а чтобы на финишном экране нарисовать количество очков, мы просто дергаем getPoints у движка